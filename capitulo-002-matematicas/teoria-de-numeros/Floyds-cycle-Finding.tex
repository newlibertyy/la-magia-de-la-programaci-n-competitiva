\subsection{Floyd’s Cycle-Finding}
Es una técnica para detectar un ciclo dentro de una secuencia creada con un función $f(x)$de la forma $g(x) \mod{M}$
donde el primer valor se da y el resto de elementos  se generaría de esta manera $\{x_{0}, x_{1}=f(x_{0}), x_{2}=f(x_{1}),  …\}$,
si tenemos la función $f(x)=3x+5 \mod{12}$ con $x_{0}=3$ tendríamos ${3, 2,11,2,11,2}$ Nuestro objetivo es encontrar 2 valores
\\$mu = $cantidad de numeros que hay antes de que inicie el ciclo
\\$lambda = $cantidad de elementos que tiene el ciclo
\\En este caso mu es 1 y lambda es 2
\\El algoritmo de detección de ciclo se hace con la analogía de la liebre y la tortuga y tiene 3 pasos
\subsubsection{primer paso:}
iniciamos la  tortuga en $f(x_{0})$ y la libre en $(f(x_{0}))$ la libre se mueve 2 veces avanzamos la tortuga $f(tortuga)$ y la libre $f(f(liebre))$ hasta que los 2 punteros coincidan
\subsubsection{paso 2:}
iniciamos $mu=0$ hacemos la liebre igual a nuestro inicio y empezamos iterar los 2 punteros paso a paso sumando le 1 a mu hasta que coincidan.
\subsubsection{paso 3:}
estando los dos punteros en el mismo lugar iniciamos $lambda=1$ y $libre=f(liebre)$
e iteramos solo con la liebre hasta que vuelva a coincidir con la tortuga sumándole 1 a lambda por cada iteración.
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=C,caption=floydCycleFinding.cpp]
ii floydCycleFinding(int x0)
{
    // paso 1:
    int tortuga = f(x0), liebre = f(f(x0));
    while (tortuga != liebre) {
        tortuga = f(tortuga);
        liebre = f(f(liebre));
    }
    // paso 2:
    int mu = 0;
    liebre = x0;
    while (tortuga != liebre) {
        tortuga = f(tortuga);
        liebre = f(liebre);
        mu++;
    }
    // paso 3:
    int lambda = 1;
    liebre = f(tortuga);
    while (tortuga != liebre) {
        liebre = f(liebre);
        lambda++;
    }
    return ii(mu, lambda);
}
\end{lstlisting}
\end{minipage}

si quieres ver este problema de una forma mas visual puedes visitar \cite{Visualgo:Online}
