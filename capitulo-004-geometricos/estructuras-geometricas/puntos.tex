\subsection{Puntos}
\subsubsection{Punto de enteros}
\begin{lstlisting}[style=C]
// struct point_i { int x, y; };
// basic raw form, minimalist mode
struct point_i { int x, y;
// whenever possible, work with point_i
point_i() { x = y = 0; }
// default constructor
point_i(int _x, int _y) : x(_x), y(_y) {} };
// user-defined
\end{lstlisting}
\subsubsection{Punto de reales}
\begin{lstlisting}[style=C]
struct point { double x, y;
// only used if more precision is needed
point() { x = y = 0.0; }
// default constructor
point(double _x, double _y) : x(_x), y(_y) {} };
// user-defined
\end{lstlisting}
\subsubsection{ordenamiento de puntos}
\begin{lstlisting}[style=C]
struct point { double x, y;
point() { x = y = 0.0; }
point(double _x, double _y) : x(_x), y(_y) {}
bool operator < (point other) const { // override less than operator
if (fabs(x - other.x) > EPS)
// useful for sorting
	return x < other.x;
// first criteria , by x-coordinate
return y < other.y; } };
// second criteria, by y-coordinate
// in int main(), assuming we already have a populated vector<point> P
sort(P.begin(), P.end());
// comparison operator is defined above
\end{lstlisting}
\subsubsection{Saber si dos puntos son iguales}
\begin{lstlisting}[style=C]
struct point { double x, y;
point() { x = y = 0.0; }
point(double _x, double _y) : x(_x), y(_y) {}
// use EPS (1e-9) when testing equality of two floating points
bool operator == (point other) const {
return (fabs(x - other.x) < EPS && (fabs(y - other.y) < EPS)); } };
\end{lstlisting}
\subsubsection{Distancia euclÃ­dea entre 2 puntos}
\begin{lstlisting}[style=C]
double dist(point p1, point p2) {
// Euclidean distance
// hypot(dx, dy) returns sqrt(dx * dx + dy * dy)
return hypot(p1.x - p2.x, p1.y - p2.y); }
// return double
\end{lstlisting}
\subsubsection{Rotar un punto con respecto al origen}
\begin{lstlisting}[style=C]
// rotate p by theta degrees CCW w.r.t origin (0, 0)
point rotate(point p, double theta) {
double rad = DEG_to_RAD(theta);
// multiply theta with PI / 180.0
return point(p.x * cos(rad) - p.y * sin(rad),
p.x * sin(rad) + p.y * cos(rad)); }
\end{lstlisting}
