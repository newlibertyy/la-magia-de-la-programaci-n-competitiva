\chapter{geometricos}
\section{formulas de geometría}
\begin{itemize}
\item $\frac{a}{sin(A)}=\frac{b}{sin(B)}=\frac{c}{sin(C)}$ 
\end{itemize}
\section{estructuras geométricas}
\subsection{puntos}
\subsubsection{punto de enteros}
\begin{lstlisting}[style=C]
// struct point_i { int x, y; };
// basic raw form, minimalist mode
struct point_i { int x, y;
// whenever possible, work with point_i
point_i() { x = y = 0; }
// default constructor
point_i(int _x, int _y) : x(_x), y(_y) {} };
// user-defined
\end{lstlisting}
\subsubsection{punto de reales}
\begin{lstlisting}[style=C]
struct point { double x, y;
// only used if more precision is needed
point() { x = y = 0.0; }
// default constructor
point(double _x, double _y) : x(_x), y(_y) {} };
// user-defined
\end{lstlisting}
\subsubsection{ordenamiento de puntos}
\begin{lstlisting}[style=C]
struct point { double x, y;
point() { x = y = 0.0; }
point(double _x, double _y) : x(_x), y(_y) {}
bool operator < (point other) const { // override less than operator
if (fabs(x - other.x) > EPS)
// useful for sorting
	return x < other.x;
// first criteria , by x-coordinate
return y < other.y; } };
// second criteria, by y-coordinate
// in int main(), assuming we already have a populated vector<point> P
sort(P.begin(), P.end());
// comparison operator is defined above
\end{lstlisting}
\subsubsection{saber si dos puntos son iguales}
\begin{lstlisting}[style=C]
struct point { double x, y;
point() { x = y = 0.0; }
point(double _x, double _y) : x(_x), y(_y) {}
// use EPS (1e-9) when testing equality of two floating points
bool operator == (point other) const {
return (fabs(x - other.x) < EPS && (fabs(y - other.y) < EPS)); } };
\end{lstlisting}
\subsubsection{distancia euclídea entre 2 puntos}
\begin{lstlisting}[style=C]
double dist(point p1, point p2) {
// Euclidean distance
// hypot(dx, dy) returns sqrt(dx * dx + dy * dy)
return hypot(p1.x - p2.x, p1.y - p2.y); }
// return double
\end{lstlisting}
\subsubsection{rotar un punto con respecto al origen}
\begin{lstlisting}[style=C]
// rotate p by theta degrees CCW w.r.t origin (0, 0)
point rotate(point p, double theta) {
double rad = DEG_to_RAD(theta);
// multiply theta with PI / 180.0
return point(p.x * cos(rad) - p.y * sin(rad),
p.x * sin(rad) + p.y * cos(rad)); }
\end{lstlisting}
\subsection{lineas}
\begin{lstlisting}[style=C]
struct line { double a, b, c; };
// a way to represent a line
\end{lstlisting}
\subsubsection{hallar una recta con 2 puntos}
\begin{lstlisting}[style=C]
// the answer is stored in the third parameter (pass by reference)
void pointsToLine(point p1, point p2, line &l) {
if (fabs(p1.x - p2.x) < EPS) {
// vertical line is fine
l.a = 1.0;
l.b = 0.0;
l.c = -p1.x;
// default values
} else {
l.a = -(double)(p1.y - p2.y) / (p1.x - p2.x);
l.b = 1.0;
// IMPORTANT: we fix the value of b to 1.0
l.c = -(double)(l.a * p1.x) - p1.y;
} }
\end{lstlisting}
\subsubsection{saber si dos lineas son paralelas}
\begin{lstlisting}[style=C]
bool areParallel(line l1, line l2) {
// check coefficients a & b
return (fabs(l1.a-l2.a) < EPS) && (fabs(l1.b-l2.b) < EPS); }
\end{lstlisting}
\subsubsection{saber si 2 lineas son iguales}
\begin{lstlisting}[style=C]
bool areSame(line l1, line l2) {
// also check coefficient c
return areParallel(l1 ,l2) && (fabs(l1.c - l2.c) < EPS); }
\end{lstlisting}
\subsubsection{intersección entre 2 lineas}
\subsection{vectores}
\subsection{círculos}
\subsubsection{ángulos en una circunferencia}
\subsection{triángulos}
\subsection{vectores}
\section{representación de un polígono}
\section{perímetro de un polígono}
\section{area de un polígono}
\section{comprobar si un punto esta dentro de un polígono}
\section{comprobar que un polígono es convexo}
\section{cortar un polígono con una linea recta}
\section{cubierta convexa}