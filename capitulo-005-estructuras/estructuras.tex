\chapter{Estructura de datos}
\section{Descripción y Motivación}

Una estructura de datos es la manera en la cual se organiza la información, por esta razon es posible que este capítulo sea el que más uses en tu vida cotidiana como programador.
\\Comencemos imaginando dos bibliotecas, la primera es muy estricta con sus reglas y todas las personas que leen un libro, deben regresarlo a su ubicación. En cambio la segunda biblioteca no tiene un orden, los libros estan regados por todas partes y las personas que los utilizan los dejan tirados donde sea. A primera vista pareciera que la segunda biblioteca no sirve para nada, pero en realidad si tu solo deseas ir a leer cualquier cosa y luego no tener que preocuparte de donde dejar el libro la segunda biblioteca seria ideal. A lo que quiero llegar es que hay distintas formas de ordenar la información, y algunas sirven para mejorar el desempeño en algunas areas sacrificando otras, no existe una estructura perfecta que haga bien todo al mismo tiempo.
\\Las principales operaciones sobre las estructuras son:
\begin{itemize}
    \item Insertar
    \item Buscar
    \item Borrar
    \item Actualizar
\end{itemize}
Conocer las principales estructuras de datos y entender muy bien el problema al que nos enfrentemos seran la clave para idear una solución optima.

\section{Complejidad}
No es la intención de este libro dar una explicación detallada de lo que es la complejidad de algoritmos, solo daremos una descripcion por encima de la notación big $O$. Esta notación nos dice cuantas ejecuciones realizaria un algoritmo en el peor de los casos, por ejemplo si tenemos que buscar un libro dentro de la biblioteca desordenada, la complejidad seria big $O(n)$ siendo n la cantidad de libros, ya que en el peor de los casos tendriamos que buscar uno por uno hasta el último libro.

\section{Estructuras de datos lineales}

Una estructura de datos es considerada lineal si todos sus elementos estan organizados en linea, por ejemplo en un arreglo de izquierda a derecha.
\\En la mayoria de lenguajes de programación podemos distinguir entre arreglos estaticos y arreglos dinamicos, a los arreglos estaticos les definimos un tamaño y es inalterable. 
\\\begin{minipage}{\textwidth}
\begin{lstlisting}[style=C,caption=arregloEstatico.cpp]
int main(){
    string palabras[] = {"hola","adios","tres"};
    cout<<palabras[2]<<endl;
}
\end{lstlisting}
\end{minipage}
\\Los arreglos comienzan con el indice 0 siendo palabras[0] = ``hola", palabras[1] = ``adios"{} y palabras[2]=``tres".
\subsection{Arreglos dinámicos}
Los arreglos estaticos son muy utiles cuando sabemos exactamente el tamaño de elementos que usaremos, su complejidad en las diferentes operaciones es:
\begin{itemize}
    \item Insertar/Actualizar $O(1)$ si conocemos la casilla donde insertaremos o actualizaremos, si no $O(n)$
    \item Buscar   $O(1)$ (cuando conocemos el indice), si no $O(n)$
    \item Borrar   $O(1)$ o $O(n)$ esta es una operacion complicada, ya que al borrar un elemento dejamos el espacio vacio, y lo más tipico seria correr todos los elementos de la derecha a la izquierda
\end{itemize}
Para entender un poco más esto imaginemos una estanteria de libros, donde solo caben 10 libros. Esta vacia y podemos empezar a meter libros donde queramos, pero si no tenemos un orden a la hora de ponerlos cuando esta más llena nos tomara más tiempo encontrar un espacio vacio, en cambio si vamos metiendo en orden siempre sabremos donde meter el proximo. La operación de buscar seria similar a agarrar el libro de la estanteria, si sabemos exactamente donde esta solo debemos tomarlo y ya, si no empezar a mirar uno por uno hasta encontrar el que buscamos, la operación de borrar es muy simple si solo quitamos el libro, pero hay dos cosas que podrian complicarla, la primera seria saber que libro quitaremos y la segunda si queremos que no quede el espacio vacio, pues nos tocaria correr todos los libros de la derecha hacia la izquierda para llenar el agujero. La operación de actualizar sera como una mezcla entre borrar e insertar.
\\Pero no nos asustemos, para usos prácticos es muy simple, solo usaremos arreglos estaticos para guardar información que recorreremos completa a menudo, por ejemplo si tenemos muchos amigos y a todos les queremos dar regalos:
\\\begin{minipage}{\textwidth}
\begin{lstlisting}[style=C,caption=arregloAmigos.cpp]
int main(){
    string amigos[5] = {"ana","brian","cesar","daniel","eliana"};
    string regalos[3] = {"abrazo","reloj","perfume"};

    for(int i=0;i<5;i++){
        for(int j=0;j<3;j++){
            cout<<"le regalo un "<<regalos[j]<<" a "<<amigos[i]<<endl;
        }
    }
}
\end{lstlisting}
\end{minipage}
\subsection{Arreglos esáticos}
Los arreglos dinamicos son iguales a los estaticos, excepto por que pueden agrandarse todo lo que quieran (siempre que lo soporte la RAM), otra gran diferencia es que ya traen por defecto la implementación de inserción y eliminación, esta estructura no permite huecos, por lo que su complejidad es la siguiente:
\begin{itemize}
    \item Insertar $O(1)$
    \item Buscar   $O(1)$ (cuando conocemos el indice), si no $O(n)$
    \item Borrar   $O(n)$ 
    \item actualizar $O(1)$ (cuando conocemos el indice), si no $O(n)$
\end{itemize}
Como podemos observar, sus complejidades son muy efectivas, y por eso son muy usadas en la mayoria de las ocasiones, de hecho casi cualquier problema que requiera estructura de datos se puede solucionar aplicando esta estructura, solo que obviamente no siempre es la solución óptima. Supongamos una base de datos que solo usara arreglos, seria muy lenta y poco práctica.
Un ejemplo de uso de arreglo dinámico es el siguiente:
\\\begin{minipage}{\textwidth}
\begin{lstlisting}[style=C,caption=arregloDinamicoAmigos.cpp]
int main(){
    vector<string> amigos;
    vector<string> regalos;
    string amigo,regalo;
    cout<<"ingrese todos sus amigos, uno por uno , si ya termino ingrese 0"<<endl;
    while(cin>>amigo){
        if(amigo=="0")break;
        amigos.push_back(amigo);
    }
    cout<<"ingrese todos los regalos, uno por uno , si ya termino ingrese 0"<<endl;
    while(cin>>regalo){
        if(regalo=="0")break;
        regalos.push_back(regalo);
    }

    for(int i=0;i<amigos.size();i++){
        for(int j=0;j<regalos.size();j++){
            cout<<"le regalo un "<<regalos[j]<<" a "<<amigos[i]<<endl;
        }
    }
}
\end{lstlisting}
\end{minipage}
Generalmente la unica manera de conocer el indice del elemento que estamos buscando, es que queramos recorrer el arreglo, como lo hemos hecho en los ejemplos. Asi que en la mayoria de ocasiones cuando buscamos un único elemento la complejidad es de $O(n)$, pero podemos mejorar esto, ordenando el arreglo. Como en el ejemplo de la biblioteca tener la información ordenada nos permite encontrar las cosas más rapidamente, pero sacrificamos otras cosas a cambio. Como ya lo mencionamos en estructuras de datos no hay nada perfecto para todo, tenemos dos opciones. La primera es ordenar el arreglo antes de hacer la consulta, la otra es siempre tenerlo ordenado.
Ordenar un arreglo no es una tarea fácil, por suerte la mayoria de lenguajes de programación nos provee herramientas para hacer esto, los mejores algoritmos de ordenamiento genericos tienen una complejidad de $O(n\log{}n)$, y buscar un elemento en un arreglo ordenado nos toma $O(\log{}n)$ por medio de busqueda binaria, la busqueda binaria funciona parandonos en la mitad, decidiendo si el elemento que buscamos se encuentra hacia la derecha o hacia la izquierda (lo sabemos por que estan ordenados) y repitiendo el proceso.
\imagen{minipageSize=1\linewidth,height=3cm,caption=busquedaBinaria.png}{capitulo-005-estructuras/imagenes/busquedaBinaria.png}
\\Por ejemplo si tenemos un directorio de teléfonos y estamos buscando el número de ``Sofia'', si nos paramos en la mitad del directorio encontraremos quizas las palabras que inician en ``M'', sabemos que el número que buscamos se encuentra hacia la derecha del directorio por que la ``S'' es mayor a la ``M'' asi que de una sola busqueda ya descartamos la mitad de las opciones, luego repetimos el proceso parandonos en la mitad del directorio que nos queda y esta vez nos paramos en la letra ``S'', la palabra ``Sofia'' se encuentra en esta letra asi que nos ahorramos recorrer una por una desde la ``A'' hasta la ``S'' para encontrar la pagina que buscabamos.
\\Es ineficiente ordenar un arreglo para hacer una única búsqueda, pero se vuelve efectivo a partir de una cantidad, vamos a calcular en que momento se vuelve efectivo: $S$ busquedas en un arreglo desordenado tiene una complejidad de $O(S\times{}n)$ y $S$ busquedas en un arreglo ordenado tiene una complejidad de $O(n\log{}n + S\log{}n)$. Si igualamos y despejamos $S$, obtenemos $S =\frac{nlog(n)}{n-log(n)}$ por lo tanto si nuestra cantidad de busquedas es mayor a $S$, vale la pena ordenar el arreglo antes de realizarlas.
